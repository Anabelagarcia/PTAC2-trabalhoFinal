rideEnvOpts,\n              dirname,\n              context,\n              input.filepath,\n            )\n          ) {\n            flattenedConfigs.push({\n              config: overrideEnvOpts,\n              index,\n              envName: context.envName,\n            });\n          }\n        }\n      });\n    }\n\n    // Process 'ignore' and 'only' before 'extends' items are processed so\n    // that we don't do extra work loading extended configs if a file is\n    // ignored.\n    if (\n      flattenedConfigs.some(\n        ({\n          config: {\n            options: { ignore, only },\n          },\n        }) => shouldIgnore(context, ignore, only, dirname),\n      )\n    ) {\n      return null;\n    }\n\n    const chain = emptyChain();\n    const logger = createLogger(input, context, baseLogger);\n\n    for (const { config, index, envName } of flattenedConfigs) {\n      if (\n        !(yield* mergeExtendsChain(\n          chain,\n          config.options,\n          dirname,\n          context,\n          files,\n          baseLogger,\n        ))\n      ) {\n        return null;\n      }\n\n      logger(config, index, envName);\n      yield* mergeChainOpts(chain, config);\n    }\n    return chain;\n  };\n}\n\nfunction* mergeExtendsChain(\n  chain: ConfigChain,\n  opts: ValidatedOptions,\n  dirname: string,\n  context: ConfigContext,\n  files: Set<ConfigFile>,\n  baseLogger?: ConfigPrinter,\n): Handler<boolean> {\n  if (opts.extends === undefined) return true;\n\n  const file = yield* loadConfig(\n    opts.extends,\n    dirname,\n    context.envName,\n    context.caller,\n  );\n\n  if (files.has(file)) {\n    throw new Error(\n      `Configuration cycle detected loading ${file.filepath}.\\n` +\n        `File already loaded following the config chain:\\n` +\n        Array.from(files, file => ` - ${file.filepath}`).join(\"\\n\"),\n    );\n  }\n\n  files.add(file);\n  const fileChain = yield* loadFileChain(\n    validateExtendFile(file),\n    context,\n    files,\n    baseLogger,\n  );\n  files.delete(file);\n\n  if (!fileChain) return false;\n\n  mergeChain(chain, fileChain);\n\n  return true;\n}\n\nfunction mergeChain(target: ConfigChain, source: ConfigChain): ConfigChain {\n  target.options.push(...source.options);\n  target.plugins.push(...source.plugins);\n  target.presets.push(...source.presets);\n  for (const file of source.files) {\n    target.files.add(file);\n  }\n\n  return target;\n}\n\nfunction* mergeChainOpts(\n  target: ConfigChain,\n  { options, plugins, presets }: OptionsAndDescriptors,\n): Handler<ConfigChain> {\n  target.options.push(options);\n  target.plugins.push(...(yield* plugins()));\n  target.presets.push(...(yield* presets()));\n\n  return target;\n}\n\nfunction emptyChain(): ConfigChain {\n  return {\n    options: [],\n    presets: [],\n    plugins: [],\n    files: new Set(),\n  };\n}\n\nfunction normalizeOptions(opts: ValidatedOptions): ValidatedOptions {\n  const options = {\n    ...opts,\n  };\n  delete options.extends;\n  delete options.env;\n  delete options.overrides;\n  delete options.plugins;\n  delete options.presets;\n  delete options.passPerPreset;\n  delete options.ignore;\n  delete options.only;\n  delete options.test;\n  delete options.include;\n  delete options.exclude;\n\n  // \"sourceMap\" is just aliased to sourceMap, so copy it over as\n  // we merge the options together.\n  if (Object.prototype.hasOwnProperty.call(options, \"sourceMap\")) {\n    options.sourceMaps = options.sourceMap;\n    delete options.sourceMap;\n  }\n  return options;\n}\n\nfunction dedupDescriptors<API>(\n  items: Array<UnloadedDescriptor<API>>,\n): Array<UnloadedDescriptor<API>> {\n  const map: Map<\n    Function,\n    Map<string | void, { value: UnloadedDescriptor<API> }>\n  > = new Map();\n\n  const descriptors = [];\n\n  for (const item of items) {\n    if (typeof item.value === \"function\") {\n      const fnKey = item.value;\n      let nameMap = map.get(fnKey);\n      if (!nameMap) {\n        nameMap = new Map();\n        map.set(fnKey, nameMap);\n      }\n      let desc = nameMap.get(item.name);\n      if (!desc) {\n        desc = { value: item };\n        descriptors.push(desc);\n\n        // Treat passPerPreset presets as unique, skipping them\n        // in the merge processing steps.\n        if (!item.ownPass) nameMap.set(item.name, desc);\n      } else {\n        desc.value = item;\n      }\n    } else {\n      descriptors.push({ value: item });\n    }\n  }\n\n  return descriptors.reduce((acc, desc) => {\n    acc.push(desc.value);\n    return acc;\n  }, []);\n}\n\nfunction configIsApplicable(\n  { options }: OptionsAndDescriptors,\n  dirname: string,\n  context: ConfigContext,\n  configName: string,\n): boolean {\n  return (\n    (options.test === undefined ||\n      configFieldIsApplicable(context, options.test, dirname, configName)) &&\n    (options.include === undefined ||\n      configFieldIsApplicable(context, options.include, dirname, configName)) &&\n    (options.exclude === undefined ||\n      !configFieldIsApplicable(context, options.exclude, dirname, configName))\n  );\n}\n\nfunction configFieldIsApplicable(\n  context: ConfigContext,\n  test: ConfigApplicableTest,\n  dirname: string,\n  configName: string,\n): boolean {\n  const patterns = Array.isArray(test) ? test : [test];\n\n  return matchesPatterns(context, patterns, dirname, configName);\n}\n\n/**\n * Print the ignoreList-values in a more helpful way than the default.\n */\nfunction ignoreListReplacer(\n  _key: string,\n  value: IgnoreList | IgnoreItem,\n): IgnoreList | IgnoreItem | string {\n  if (value instanceof RegExp) {\n    return String(value);\n  }\n\n  return value;\n}\n\n/**\n * Tests if a filename should be ignored based on \"ignore\" and \"only\" options.\n */\nfunction shouldIgnore(\n  context: ConfigContext,\n  ignore: IgnoreList | undefined | null,\n  only: IgnoreList | undefined | null,\n  dirname: string,\n): boolean {\n  if (ignore && matchesPatterns(context, ignore, dirname)) {\n    const message = `No config is applied to \"${\n      context.filename ?? \"(unknown)\"\n    }\" because it matches one of \\`ignore: ${JSON.stringify(\n      ignore,\n      ignoreListReplacer,\n    )}\\` from \"${dirname}\"`;\n    debug(message);\n    if (context.showConfig) {\n      console.log(message);\n    }\n    return true;\n  }\n\n  if (only && !matchesPatterns(context, only, dirname)) {\n    const message = `No config is applied to \"${\n      context.filename ?? \"(unknown)\"\n    }\" because it fails to match one of \\`only: ${JSON.stringify(\n      only,\n      ignoreListReplacer,\n    )}\\` from \"${dirname}\"`;\n    debug(message);\n    if (context.showConfig) {\n      console.log(message);\n    }\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Returns result of calling function with filename if pattern is a function.\n * Otherwise returns result of matching pattern Regex with filename.\n */\nfunction matchesPatterns(\n  context: ConfigContext,\n  patterns: IgnoreList,\n  dirname: string,\n  configName?: string,\n): boolean {\n  return patterns.some(pattern =>\n    matchPattern(pattern, dirname, context.filename, context, configName),\n  );\n}\n\nfunction matchPattern(\n  pattern: IgnoreItem,\n  dirname: string,\n  pathToTest: string | undefined,\n  context: ConfigContext,\n  configName?: string,\n): boolean {\n  if (typeof pattern === \"function\") {\n    return !!endHiddenCallStack(pattern)(pathToTest, {\n      dirname,\n      envName: context.envName,\n      caller: context.caller,\n    });\n  }\n\n  if (typeof pathToTest !== \"string\") {\n    throw new ConfigError(\n      `Configuration contains string/RegExp pattern, but no filename was passed to Babel`,\n      configName,\n    );\n  }\n\n  if (typeof pattern === \"string\") {\n    pattern = pathPatternToRegex(pattern, dirname);\n  }\n  return pattern.test(pathToTest);\n}\n"],"mappings":"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